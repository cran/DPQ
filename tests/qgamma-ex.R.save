###---> Find places where qgamma() is not so precise  PR#2214 :
res <- cbind(p=1,df=1,rE=1)[-1,]
for(p in runif(100)) for(df in rlnorm(100)) {
    r <- 1- pchisq(qchisq(p, df),df)/p
    if(abs(r) > 1e-8) res <- rbind(res, c(p,df,r))
}
## do the above a few times, then
hist(res[,"rE"])
plot(res[,1:2])##--> quite interesting : all along one curve
## p <= 1/2  and df <= 1 (about) !!

res <- res[1:1095,]
### use df in runif(.):

for(p in runif(100)/2) for(df in runif(100)) {
    qq <- qchisq(p, df)
    if(qq > 0 && p > 0) {
        r <- 1- pchisq(qq, df) / p
        if(abs(r) > 1e-8) res <- rbind(res, c(p,df,r))
    }
}

library(akima)
ires <- interp(res[,1],res[,2],res[,3])
filled.contour(ires, plot.axes= {points(res[,1:2]); axis(1);axis(2)})
## non sense

library(scatterplot3d)
scatterplot3d(res, type ='h')
scatterplot3d(res[res[,'rE'] > 3e-8,], type ='h')
rL <- res[res[,'rE'] > 4e-8,]
rL <- rL[order(rL[,1],rL[,2]),]
rL
rL[rL[,'rE'] > 4.5e-8 ,]
##-                  p        df           rE
##-  [1,] 0.0004567743 0.9956147 5.083269e-08
##-  [2,] 0.0017038640 0.8289400 4.581154e-08
##-  [3,] 0.0017038640 0.8341735 5.075523e-08
##-  [4,] 0.0017038640 0.8350974 5.167518e-08
##-  [5,] 0.0017038640 0.8435000 6.073859e-08
##-  [6,] 0.0029462220 0.7745973 6.003337e-08
##-  [7,] 0.0032227382 0.7512025 4.633630e-08
##-  [8,] 0.0032227382 0.7520410 4.718239e-08
##-  [9,] 0.0032227382 0.7520559 4.719759e-08
##- [10,] 0.0032227382 0.7626802 5.916153e-08
##- [11,] 0.0032227382 0.7645367 6.150526e-08
##- [12,] 0.0032227382 0.7663026 6.380998e-08
##- [13,] 0.0032227382 0.7690659 6.756883e-08
##- [14,] 0.0063573236 0.6681729 4.743319e-08
##- [15,] 0.0082354513 0.6347265 4.596623e-08
##- [16,] 0.0082354513 0.6396982 5.208723e-08
##- [17,] 0.0087122632 0.6280341 4.633192e-08
##- [18,] 0.0087122632 0.6348482 5.505343e-08
##- [19,] 0.0112206088 0.5989482 4.948652e-08
##- [20,] 0.0112206088 0.6004991 5.156834e-08
##- [21,] 0.0112206088 0.6029700 5.504397e-08
##- [22,] 0.0112206088 0.6032288 5.541963e-08
##- [23,] 0.0129558414 0.5852532 5.570261e-08
##- [24,] 0.0129558414 0.5853885 5.590669e-08
##- [25,] 0.0194528948 0.5291932 4.870639e-08
##- [26,] 0.0227744423 0.5101647 5.005526e-08
##- [27,] 0.0235890601 0.5039322 4.734047e-08
##- [28,] 0.0260471951 0.4900469 4.531238e-08
##- [29,] 0.0289241553 0.4783687 4.769569e-08
##- [30,] 0.0289870249 0.4768123 4.571579e-08
##- [31,] 0.0295952477 0.4745798 4.631887e-08
##- [32,] 0.0305110400 0.4698827 4.503083e-08
plot(rL[,1:2])

d <- as.data.frame(res)
plot  (1/p ~ df, data = d)
points(1/p ~ df, data = as.data.frame(rL), col=2)
summary(ll <- lm(1/p ~ df + I(df^2), weights = rE, data = d),cor=TRUE)
summary(ll <- lm(1/p ~ df + I(df^2)+I(df^3)+I(df^4), weights = rE, data = d),cor=TRUE)
summary(ll <- lm(log(p) ~ log(df), weights = rE, data = d))


## Oops: another  qgamma() / qchisq() problem:  mostly NaN's !!
curve(qgamma(x, 20), 1e-16, 1e-10, log='x')
## BUG !!!!e.g.
qgamma(1e-12, 20)#-> NaN {no longer -- but curve shows inaccuracy!
NaN
## The same for other 'df' :

## --- Nice graphic :
p.qgammaSml <- function(from= 1e-110, to = 1e-5, ylim = c(0.4, 1000),
                        n = 201, k.lab = 3,
                        a1 = c(10, seq(10.1,20, by=.2), 21:105),
                        a2 = seq(110,330, by=10),
                        a3 = seq(350,1600, by=50))
{
    ## Purpose:
    ## ----------------------------------------------------------------------
    ## Arguments:
    ## ----------------------------------------------------------------------
    ## Author: Martin Maechler, Date: 22 Mar 2004, 14:23
    x <- exp(seq(log(from), log(to), length = n))

    op <- par(las=1, lab = c(10,10, 7), xaxs = "i", mex = 0.8)
    on.exit(par(op))
    plot(x, qgamma(x, a1[1]), log="xy", ylim=ylim, type='l', xaxt = "n",
         main = "qgamma(x, a) for very small x, a in [10,1600] - log-log",
         sub = R.version.string)
    lab.x <- pretty(log10(c(from,to)), 20)
    axis(1, at=10^lab.x, lab = paste("10^",formatC(lab.x),sep=''))
    if(is.nan(qgamma(1e-12, 20)))
        text(1e-60, 20, "all  NaN", cex = 2)
    if(!is.finite(qgamma(1e-140, 155)))
        text(1e-240, 5, "all +Inf", cex = 2)

    lines.txt <- function(a.s, col = par("col")) {
        col <- rep(col, length=length(a.s))
        for(i in seq(along=a.s)) {
            qx <- qgamma(x, (a <- a.s[i]))
            if(i %% k.lab == 0 &&
               any(ifi <- is.finite(qx) & qx >= ylim[1])) {
                ik <- (i%%(2*k.lab))/k.lab # = 0 or 1
                j <- quantile(which(ifi), c(.02,(1:3)/4+ ik/10, .98))
                ## "segments" around the labels :
                i0 <- 1
                for(jj in j) {
                    ii <- i0:(jj-1)
                    i2 <- jj + -1:1
                    lines(x[ii], qx[ii], col=col[i])
                    lines(x[i2], qx[i2], col=col[i], type = 'c')
                    i0 <- jj+1
                }
                text(x[j], qx[j], formatC(a), col= "gray40", cex = 0.8)
            }
            else
                lines(x, qx, col=col[i])

        }
    }
    oo <- options(warn = -1)
    lines.txt(a1[-1])
    lines.txt(a2, col= 2)
    lines.txt(a3, col= rainbow(length(a3),.8,.8,
                  start=(a3-min(a3))/(1+max(a3))))
    invisible(options(oo))
}

p.qgammaSml()

p.qgammaSml(1e-300)
p.qgammaSml(1e-300,1e-50, a2= seq(100,360, by=4), a3=seq(350,1500, by=10))
ps.do("PqgammaSml-3.ps")
p.qgammaSml(1e-300,1e-50, a2= seq(100,360, by=4), a3=seq(350,1500, by=10))
ps.end()

## The "upper" problematic corner:
p.qgammaSml(1e-19, 1e-3, a2=NULL,a3=NULL, ylim=c(.1,20))
p.qgammaSml(1e-19, 1e-3, a2=seq(1,12, by=.04), ylim=c(.1,20),a3=NULL,k.lab=10)
## no shows the problem (quite well):
## could it lie in  pgamma()'s inaccuracy, leading to qgamma() bias ?
p.qgammaSml(1e-14, 1e-3, a2=NULL,a3=NULL, ylim=c(.4,5))

## lower a \> 10

curve(qgamma(x, 19),    1e-14,    1e-9, log='x')
curve(qgamma(x, 18),    1e-14,    1e-9, log='x')
curve(qgamma(x, 15),    1e-11,    5e-9, log='x')
curve(qgamma(x, 13),    5e-10,    1e-8, log='x')
curve(qgamma(x, 11),     1e-8,    5e-8, log='x')
curve(qgamma(x, 10.5), 4.2e-8,    6e-8, log='x')
curve(qgamma(x, 10.3),   6e-8,    7e-8, log='x')
curve(qgamma(x, 10.2), 7.1e-8,  7.6e-8, log='x')
curve(qgamma(x, 10.15),7.7e-8,  7.9e-8, log='x')
curve(qgamma(x, 10.14),7.88e-8,7.92e-8, log='x',n=10001)

## no more problems for smaller a!!  here:
curve(qgamma(x, 10.13), 1e-10, 5e-4, log='x',n=20001)
curve(qgamma(x, 10.12), 1e-10, 5e-4, log='x',n=20001)
curve(qgamma(x, 10.1), 1e-10,  5e-4, log='x',n=20001)


##--- the "+Inf" / premature "0" case:
curve(qgamma(x, 155, log=TRUE), -1500, 0, log='y', n=2001,col=2)
curve(qgamma(x, 1e3, log=TRUE), -1500, 0, log='y', n=2001,col=2)
# now works, but slowly and with kink
curve(qgamma(x, 1e5, log=TRUE), -3e5,  0, log='y', n=2001,col=2)

## is the kink from pgamma() ? : no: this looks fine,
curve(pgamma(x, 1e5, log=TRUE), 1, 2e5, log='x', n=2001,col=2)
## but
curve( dgamma(x, 1e5),           .5e5, 2e5); par(new=TRUE)
curve( dgamma(x, 1e5, log=TRUE), .5e5, 2e5, col=2, yaxt="n")
axis(4,col.axis=2); par(new=TRUE)
curve( pgamma(x, 1e5), .5e5, 2e5, n=2001, col=3); par(new=TRUE)
curve( pgamma(x, 1e5, log=TRUE), .5e5, 2e5, n=2001, col=4); par(new=TRUE)
curve(-pgamma(x, 1e5, log=TRUE,lower=FALSE), .5e5, 2e5, n=2001, col=4)

curve(-pgamma(x, 1e5, log=TRUE), 9e4, 12e4, log='xy', n=2001,col=2) ## ??
curve(-pgamma(x, 1e5, log=TRUE,lower=FALSE), 9e4, 12e4, log='xy', n=2001,col=2)
curve(-pgamma(x, 1e5, log=TRUE,lower=FALSE), 100, 12e4, log='x', n=2001,col=2)

x <- 10^seq(2,6, length=4001)
qx <- qgamma(pgamma(x, 1e5, log=TRUE), 1e5, log=TRUE)
plot(x, qx, type ='l', col=2, asp = 1); abline(0,1, lty=3)
1

###-------------  Approximations of  qgamma() ------
##

## Wilson-Hilferty  for Chisquare : (not always good !)
qchisqWH <- function(p,df, lower.tail=TRUE, log.p=FALSE) {
    p1 <- 2/(9*df)
    df*(qnorm(p, lower=lower.tail, log.p=log.p)*sqrt(p1)+ 1- p1)^3
}

## Kennedy & Gentle p.118 (according to Joe Newton's  "Comp.Statist",p.25f.)
##
## This is just a cheap version of "Phase I  Starting Approximation"
## used  in  R's  qgamma.c, i.e. AS 91 (JRSS, 1979) :
qchisqKG <- function(p, df, ncp=0, lower.tail=TRUE, log.p=FALSE)
{
    if(ncp !=0) stop("'ncp' must be 0")
    if(lower.tail) {
        u <- if(!log.p) p else exp(p)
        Iu <- 1-u
    } else { ## upper tail: compute u  _and_ Iu := 1-u :
        if(!log.p) {u <- 1-p; Iu <- p } else {u <- -expm1(p); Iu <- exp(p)}
    }
    if(df < -1.24 * log(u)) { ## no Wilson-Hilferty
        (u * df * gamma(df/2) * 2^(df/2 - 1))^ (2/df)
    }
    else { ## Wilson-Hilferty:
        q0 <- qchisqWH(p, df, lower.tail=lower.tail, log.p=log.p)
        if(q0 <= 2.2*df + 6)
            q0
        else ## the following gives NaN when u=1 (numerically),
             ## e.g., (-38, 1, lower=F, log=TRUE):
            -2 * log((Iu*gamma(df/2)) / ((q0/2)^(df/2 - 1)))
    }
}
